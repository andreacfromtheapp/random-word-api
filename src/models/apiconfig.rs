//! API configuration module
//!
//! This module provides comprehensive configuration management for the random word API,
//! supporting multiple configuration sources including command-line arguments, TOML files,
//! and environment variables. It handles configuration parsing, validation, and file
//! generation for different deployment scenarios.
//!
//! # Configuration Sources
//!
//! The module supports three primary configuration methods:
//! - Command-line arguments for direct parameter specification
//! - TOML configuration files for structured settings management
//! - Environment files for containerized and cloud deployments
//!
//! # Configuration Hierarchy
//!
//! Configuration sources are processed in priority order:
//! 1. Environment files (highest priority)
//! 2. TOML configuration files
//! 3. Command-line arguments (lowest priority)
//!
//! # File Generation
//!
//! The module includes utilities for generating template configuration files
//! with default values, supporting both TOML and environment file formats.
//!
//! # Validation
//!
//! All configuration values are validated for correctness including network
//! addresses, port ranges, database URLs, and boolean flags.

// Application configuration
use serde::{Deserialize, Serialize};
use std::{fmt, net::IpAddr, path::PathBuf};

use crate::cli::Cli;

/// Main API configuration structure containing all runtime settings.
///
/// This struct represents the complete configuration for the random word API,
/// including server binding settings, database connectivity, and OpenAPI
/// documentation options. It supports serialization for file-based configuration
/// and provides methods for loading from various sources.
///
/// # Configuration Fields
///
/// - `address`: IP address for server binding (IPv4 or IPv6)
/// - `port`: TCP port number for HTTP server
/// - `database_url`: SQLite database connection string
/// - `openapi`: OpenAPI documentation interface settings
///
/// # Serialization Support
///
/// The struct implements Serde traits for:
/// - TOML file serialization and deserialization
/// - Environment variable conversion through Display trait
/// - JSON serialization for debugging and API responses
///
/// # Thread Safety
///
/// The Clone implementation allows the configuration to be shared safely
/// across threads when wrapped in appropriate synchronization primitives.
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct ApiConfig {
    pub address: IpAddr,
    pub port: u16,
    pub database_url: String,
    pub openapi: OpenApiDocs,
}

/// File format types for configuration file generation.
///
/// This enum distinguishes between different configuration file formats
/// that can be generated by the CLI utility commands. Each format serves
/// different deployment and development scenarios.
///
/// # Format Characteristics
///
/// - `Toml`: Structured configuration with sections and type safety
/// - `EnvFile`: Key-value pairs suitable for environment variable loading
#[derive(Debug, Serialize, Deserialize, Clone)]
pub enum FileKind {
    /// TOML configuration file format.
    ///
    /// Uses structured TOML syntax with sections and typed values.
    /// Provides better readability and organization for complex
    /// configurations with nested settings.
    Toml,
    /// Environment variable file format.
    ///
    /// Uses simple KEY=value pairs compatible with dotenv libraries
    /// and container orchestration systems. Ideal for Docker and
    /// cloud deployments.
    EnvFile,
}

impl ApiConfig {
    /// Creates a new ApiConfig instance with specified values.
    ///
    /// This constructor initializes all configuration fields with provided
    /// values. It serves as the primary method for creating configuration
    /// instances from parsed CLI arguments or file contents.
    ///
    /// # Arguments
    ///
    /// * `address` - IP address for server binding
    /// * `port` - TCP port number for HTTP server
    /// * `database_url` - Database connection string
    /// * `openapi` - OpenAPI documentation settings
    ///
    /// # Returns
    ///
    /// A new ApiConfig instance with all fields initialized.
    pub fn new(address: IpAddr, port: u16, database_url: String, openapi: OpenApiDocs) -> Self {
        Self {
            address,
            port,
            database_url,
            openapi,
        }
    }

    /// Generates a configuration file with default values.
    ///
    /// This method creates template configuration files in either TOML or
    /// environment variable format. The generated files contain all available
    /// configuration options with sensible defaults that can be customized
    /// for specific deployment needs.
    ///
    /// # Arguments
    ///
    /// * `file` - Path where the configuration file should be created
    /// * `kind` - Format type (TOML or environment file)
    ///
    /// # Returns
    ///
    /// * `Ok(())` - File created successfully
    /// * `Err(anyhow::Error)` - File creation failed or serialization error
    ///
    /// # File Creation
    ///
    /// The method will create the file and any necessary parent directories.
    /// If the file already exists, it will be overwritten with new content.
    ///
    /// # Generated Content
    ///
    /// Files are populated with default configuration values that match
    /// the CLI argument defaults, ensuring consistency across configuration
    /// methods.
    pub fn gen_file(file: &PathBuf, kind: FileKind) -> Result<(), anyhow::Error> {
        use std::fs::File;
        use std::io::prelude::*;

        // set default config values
        let default_configs = Self::default();

        let what_file = match kind {
            FileKind::Toml => toml::to_string(&default_configs)?,
            FileKind::EnvFile => Self::to_string(&default_configs),
        };

        // create the default file
        let mut buffer = File::create(file)?;
        // write all lines from the above steps
        buffer.write_all(what_file.as_bytes())?;

        println!("configuration file '{file:?}' created successfully");

        Ok(())
    }

    /// Creates ApiConfig from CLI arguments with source precedence handling.
    ///
    /// This method processes CLI arguments to determine the configuration source
    /// and loads settings accordingly. It implements the configuration hierarchy
    /// where environment files take precedence over TOML files, which take
    /// precedence over direct command-line arguments.
    ///
    /// # Configuration Source Priority
    ///
    /// 1. Environment file (--env-file flag)
    /// 2. TOML configuration file (--config flag)
    /// 3. Direct command-line arguments (default)
    ///
    /// # Arguments
    ///
    /// * `cli` - Parsed CLI structure containing arguments and flags
    ///
    /// # Returns
    ///
    /// * `Ok(ApiConfig)` - Successfully loaded configuration
    /// * `Err(anyhow::Error)` - File parsing error or invalid configuration
    ///
    /// # Error Handling
    ///
    /// Errors can occur from:
    /// - File not found or permission issues
    /// - Invalid TOML syntax or structure
    /// - Missing required environment variables
    /// - Invalid configuration values (IP addresses, ports, etc.)
    pub fn from_cli(cli: &Cli) -> Result<Self, anyhow::Error> {
        // if --env-file was used
        if let Some(file) = &cli.cfg.env_file {
            Self::from_env_file(file)
        // if --config was used
        } else if let Some(file) = &cli.cfg.config {
            Self::from_config_file(file)
        // if positional parameters were used
        } else {
            Self::from_cli_args(cli)
        }
    }

    /// Creates ApiConfig from environment variable file.
    ///
    /// This method loads configuration from a .env file containing environment
    /// variables. It uses the `dotenvy` crate to parse the file and extract
    /// configuration values, then validates and converts them to appropriate types.
    ///
    /// # Environment Variables
    ///
    /// Expected variables in the file:
    /// - `BIND_ADDR`: Server IP address (IPv4 or IPv6)
    /// - `BIND_PORT`: Server port number (1-65535)
    /// - `DATABASE_URL`: SQLite database connection string
    /// - `ENABLE_SWAGGER_UI`: Boolean flag for SwaggerUI
    /// - `ENABLE_REDOC`: Boolean flag for Redoc documentation
    /// - `ENABLE_SCALAR`: Boolean flag for Scalar documentation
    /// - `ENABLE_RAPIDOC`: Boolean flag for RapiDoc documentation
    ///
    /// # Arguments
    ///
    /// * `file` - Path to the environment file to load
    ///
    /// # Returns
    ///
    /// * `Ok(ApiConfig)` - Successfully parsed configuration
    /// * `Err(anyhow::Error)` - File not found, parsing error, or invalid values
    ///
    /// # File Override
    ///
    /// Uses `dotenvy::from_filename_override` to ensure file variables
    /// take precedence over existing environment variables.
    pub fn from_env_file(file: &PathBuf) -> Result<Self, anyhow::Error> {
        use std::str::FromStr;

        // get all environment variable from the environment file
        dotenvy::from_filename_override(file)?;

        // set the variables as needed
        Ok(Self::new(
            IpAddr::from_str(dotenvy::var("BIND_ADDR")?.trim())?,
            u16::from_str(dotenvy::var("BIND_PORT")?.trim())?,
            dotenvy::var("DATABASE_URL")?.trim().to_owned(),
            OpenApiDocs::new(
                bool::from_str(dotenvy::var("ENABLE_SWAGGER_UI")?.trim())?,
                bool::from_str(dotenvy::var("ENABLE_REDOC")?.trim())?,
                bool::from_str(dotenvy::var("ENABLE_SCALAR")?.trim())?,
                bool::from_str(dotenvy::var("ENABLE_RAPIDOC")?.trim())?,
            ),
        ))
    }

    /// Creates ApiConfig from TOML configuration file.
    ///
    /// This method loads configuration from a structured TOML file containing
    /// all API settings organized in sections. It reads the entire file,
    /// parses the TOML content, and deserializes it into the ApiConfig struct.
    ///
    /// # TOML Structure
    ///
    /// Expected file structure:
    /// ```toml
    /// address = "0.0.0.0"
    /// port = 3000
    /// database_url = "sqlite:random-words.db"
    ///
    /// [openapi]
    /// enable_swagger_ui = false
    /// enable_redoc = false
    /// enable_scalar = false
    /// enable_rapidoc = false
    /// ```
    ///
    /// # Arguments
    ///
    /// * `file` - Path to the TOML configuration file to load
    ///
    /// # Returns
    ///
    /// * `Ok(ApiConfig)` - Successfully parsed configuration
    /// * `Err(anyhow::Error)` - File not found, invalid TOML, or missing fields
    ///
    /// # File Processing
    ///
    /// The method reads the entire file into memory as a string and uses
    /// the `toml` crate for parsing and type conversion.
    pub fn from_config_file(file: &PathBuf) -> Result<Self, anyhow::Error> {
        // read the config file line by line and store it in a String
        let file_content = std::fs::read(file)?
            .iter()
            .map(|c| *c as char)
            .collect::<String>();

        // parse the configuration String and store in model Struct
        let my_configs: Self = toml::from_str(&file_content)?;

        // set the variables as needed
        Ok(Self::new(
            my_configs.address,
            my_configs.port,
            my_configs.database_url.clone(),
            OpenApiDocs::new(
                my_configs.openapi.enable_swagger_ui,
                my_configs.openapi.enable_redoc,
                my_configs.openapi.enable_scalar,
                my_configs.openapi.enable_rapidoc,
            ),
        ))
    }

    /// Creates ApiConfig directly from command-line arguments.
    ///
    /// This method extracts configuration values directly from the parsed
    /// CLI arguments without involving external files. It serves as the
    /// fallback configuration method when no file-based configuration
    /// is specified.
    ///
    /// # Arguments
    ///
    /// * `cli` - Parsed CLI structure containing all argument values
    ///
    /// # Returns
    ///
    /// * `Ok(ApiConfig)` - Configuration created from CLI arguments
    /// * `Err(anyhow::Error)` - Invalid argument values or validation failure
    ///
    /// # Validation
    ///
    /// All CLI arguments are pre-validated by the `clap` crate and `validator`
    /// traits, so this method primarily handles type conversion and structure
    /// creation rather than validation.
    ///
    /// # Default Values
    ///
    /// Uses the default values specified in the CLI argument definitions,
    /// ensuring consistency between configuration methods.
    pub fn from_cli_args(cli: &Cli) -> Result<Self, anyhow::Error> {
        // set the variables as needed
        Ok(Self::new(
            cli.arg.address,
            cli.arg.port,
            cli.arg.database_url.clone(),
            OpenApiDocs::new(
                cli.arg.with_swagger_ui,
                cli.arg.with_redoc,
                cli.arg.with_scalar,
                cli.arg.with_rapidoc,
            ),
        ))
    }
}

/// Formats ApiConfig as environment variable file content.
///
/// This implementation converts the configuration structure into a format
/// suitable for .env files, with each setting represented as a KEY=value
/// pair. The output can be written directly to environment files for
/// container deployments.
///
/// # Format
///
/// The output includes:
/// - Server binding variables (BIND_ADDR, BIND_PORT)
/// - Database connection variable (DATABASE_URL)
/// - OpenAPI documentation flags
/// - Proper quoting for string values
///
/// # Usage
///
/// This trait is used internally by the file generation utilities to
/// create environment variable files with proper formatting.
impl fmt::Display for ApiConfig {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "BIND_ADDR=\"{}\"\nBIND_PORT={}\nDATABASE_URL={}\n\n{}",
            self.address, self.port, self.database_url, self.openapi
        )
    }
}

/// Provides default configuration values for development and testing.
///
/// This implementation defines sensible defaults that work out of the box
/// for development environments. The defaults prioritize ease of setup
/// and local development over production security considerations.
///
/// # Default Values
///
/// - `address`: 0.0.0.0 (binds to all interfaces)
/// - `port`: 3000 (common development port)
/// - `database_url`: sqlite:random-words.db (local SQLite file)
/// - `openapi`: All documentation interfaces disabled
///
/// # Development Focus
///
/// Defaults are optimized for local development and testing scenarios.
/// Production deployments should use explicit configuration files or
/// environment variables with appropriate security settings.
impl Default for ApiConfig {
    fn default() -> Self {
        use std::str::FromStr;

        ApiConfig {
            address: IpAddr::from_str("0.0.0.0").unwrap(),
            port: u16::from_str("3000").unwrap(),
            database_url: "sqlite:random-words.db".to_string(),
            openapi: OpenApiDocs::default(),
        }
    }
}

/// OpenAPI documentation interface configuration.
///
/// This struct controls which OpenAPI documentation interfaces are enabled
/// for the API. Each interface provides different features and user experiences
/// for exploring and testing the API endpoints.
///
/// # Documentation Interfaces
///
/// - `enable_swagger_ui`: Interactive API explorer with testing capabilities
/// - `enable_redoc`: Clean, readable documentation with three-panel layout
/// - `enable_scalar`: Modern interface with advanced features
/// - `enable_rapidoc`: Lightweight, fast-loading documentation
///
/// # Performance Considerations
///
/// Enabling multiple documentation interfaces increases memory usage and
/// startup time. For production deployments, consider enabling only the
/// interfaces that are actively used.
///
/// # Default Behavior
///
/// All interfaces are disabled by default to minimize resource usage
/// and reduce attack surface in production environments.
#[derive(Default, Debug, Serialize, Deserialize, Clone)]
pub struct OpenApiDocs {
    pub enable_swagger_ui: bool,
    pub enable_redoc: bool,
    pub enable_scalar: bool,
    pub enable_rapidoc: bool,
}

impl OpenApiDocs {
    /// Creates a new OpenApiDocs configuration with specified interface settings.
    ///
    /// This constructor allows explicit control over which documentation
    /// interfaces are enabled. It provides a convenient way to configure
    /// documentation settings when loading from CLI arguments or files.
    ///
    /// # Arguments
    ///
    /// * `enable_swagger_ui` - Enable SwaggerUI interactive interface
    /// * `enable_redoc` - Enable Redoc documentation interface
    /// * `enable_scalar` - Enable Scalar modern interface
    /// * `enable_rapidoc` - Enable RapiDoc lightweight interface
    ///
    /// # Returns
    ///
    /// A new OpenApiDocs instance with specified interface settings.
    ///
    /// # Resource Usage
    ///
    /// Each enabled interface adds to memory usage and startup time.
    /// Consider enabling only necessary interfaces for production use.
    pub fn new(
        enable_swagger_ui: bool,
        enable_redoc: bool,
        enable_scalar: bool,
        enable_rapidoc: bool,
    ) -> Self {
        Self {
            enable_swagger_ui,
            enable_redoc,
            enable_scalar,
            enable_rapidoc,
        }
    }
}

/// Formats OpenApiDocs as environment variable section.
///
/// This implementation converts the OpenAPI documentation settings into
/// environment variable format suitable for .env files. The output includes
/// a section header and all boolean flags formatted as environment variables.
///
/// # Format
///
/// The output includes:
/// - Section header comment for organization
/// - Boolean values formatted as environment variables
/// - Consistent naming convention for all flags
///
/// # Integration
///
/// This trait is used by the ApiConfig Display implementation to include
/// OpenAPI settings in generated environment files.
impl fmt::Display for OpenApiDocs {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "# OpenAPI Docs\nENABLE_SWAGGER_UI={}\nENABLE_REDOC={}\nENABLE_SCALAR={}\nENABLE_RAPIDOC={}\n",
            self.enable_swagger_ui, self.enable_redoc, self.enable_scalar, self.enable_rapidoc
        )
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::net::IpAddr;
    use std::str::FromStr;

    #[test]
    fn test_api_config_new() {
        let address = IpAddr::from_str("127.0.0.1").unwrap();
        let openapi = OpenApiDocs::new(true, false, true, false);
        let config = ApiConfig::new(address, 8080, "sqlite:test.db".to_string(), openapi);

        assert_eq!(config.address, address);
        assert_eq!(config.port, 8080);
        assert_eq!(config.database_url, "sqlite:test.db");
        assert!(config.openapi.enable_swagger_ui);
        assert!(!config.openapi.enable_redoc);
    }

    #[test]
    fn test_api_config_default() {
        let config = ApiConfig::default();

        assert_eq!(config.address, IpAddr::from_str("0.0.0.0").unwrap());
        assert_eq!(config.port, 3000);
        assert_eq!(config.database_url, "sqlite:random-words.db");
        assert!(!config.openapi.enable_swagger_ui);
        assert!(!config.openapi.enable_redoc);
        assert!(!config.openapi.enable_scalar);
        assert!(!config.openapi.enable_rapidoc);
    }

    #[test]
    fn test_openapi_docs_new() {
        let docs = OpenApiDocs::new(true, false, true, false);

        assert!(docs.enable_swagger_ui);
        assert!(!docs.enable_redoc);
        assert!(docs.enable_scalar);
        assert!(!docs.enable_rapidoc);
    }

    #[test]
    fn test_openapi_docs_default() {
        let docs = OpenApiDocs::default();

        assert!(!docs.enable_swagger_ui);
        assert!(!docs.enable_redoc);
        assert!(!docs.enable_scalar);
        assert!(!docs.enable_rapidoc);
    }

    #[test]
    fn test_api_config_display() {
        let address = IpAddr::from_str("192.168.1.1").unwrap();
        let openapi = OpenApiDocs::new(true, false, true, false);
        let config = ApiConfig::new(address, 9000, "sqlite:display_test.db".to_string(), openapi);

        let output = format!("{config}");
        assert!(output.contains("BIND_ADDR=\"192.168.1.1\""));
        assert!(output.contains("BIND_PORT=9000"));
        assert!(output.contains("DATABASE_URL=sqlite:display_test.db"));
        assert!(output.contains("ENABLE_SWAGGER_UI=true"));
        assert!(output.contains("ENABLE_REDOC=false"));
        assert!(output.contains("ENABLE_SCALAR=true"));
        assert!(output.contains("ENABLE_RAPIDOC=false"));
    }

    #[test]
    fn test_openapi_docs_display() {
        let docs = OpenApiDocs::new(false, true, false, true);
        let output = format!("{docs}");

        assert!(output.contains("# OpenAPI Docs"));
        assert!(output.contains("ENABLE_SWAGGER_UI=false"));
        assert!(output.contains("ENABLE_REDOC=true"));
        assert!(output.contains("ENABLE_SCALAR=false"));
        assert!(output.contains("ENABLE_RAPIDOC=true"));
    }

    #[test]
    fn test_file_kind_variants() {
        // Test that FileKind variants exist and can be created
        let _toml = FileKind::Toml;
        let _env = FileKind::EnvFile;

        // Test Debug implementation
        assert_eq!(format!("{:?}", FileKind::Toml), "Toml");
        assert_eq!(format!("{:?}", FileKind::EnvFile), "EnvFile");
    }
}
